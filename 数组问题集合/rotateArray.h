/************************************************************************/
/** 
* 题目：旋转数组
* 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
* 
* 示例 1:
* 输入: [1,2,3,4,5,6,7] 和 k = 3
* 输出: [5,6,7,1,2,3,4]
* 解释:
* 向右旋转 1 步: [7,1,2,3,4,5,6]
* 向右旋转 2 步: [6,7,1,2,3,4,5]
* 向右旋转 3 步: [5,6,7,1,2,3,4]
* 
* 示例 2:
* 输入: [-1,-100,3,99] 和 k = 2
* 输出: [3,99,-1,-100]
* 解释: 
* 向右旋转 1 步: [99,-1,-100,3]
* 向右旋转 2 步: [3,99,-1,-100]
* 
* 说明:
* 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
* 要求使用空间复杂度为 O(1) 的 原地 算法。
*/
/************************************************************************/

#pragma once
#include <vector>
#include <iostream>

using namespace std;
namespace Solution
{
	//+++++++++++++++++++++++++++++++++++++++++++++++++//
	// 解法1 借助辅助空间
	// 1.借助辅助空间，将移动后i+k超出len的元素，装入新的vec，注意顺序
	// 2.从后往前，将其余元素向后移动k
	// 3.将辅助vec的元素复制到前面的空间
	// 
	//+++++++++++++++++++++++++++++++++++++++++++++++++//
	void rotate(vector<int>& nums, int k) 
	{
		if (k <= 0)
		{
			return;
		}
		int len = nums.size();
		if (len <= 0)
		{
			return;
		}

		k = k % len;	// 特别注意，k可能比len大，这时候就要取余
		vector<int> tmp;
		for (int i = len - k; i < len; ++i)
		{
			tmp.push_back(nums[i]);
		}
		for (int i = len - k - 1; i >= 0; --i)
		{
			nums[i + k] = nums[i];
		}
		for (int i = 0; i < k; ++i)
		{
			nums[i] = tmp[i];
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++//
	// 解法2 三次反转法
	// 1 2 3 4 5 6 7  len=7 k=3
	// 4 3 2 1 5 6 7  第一次反转
	// 4 3 2 1 7 6 5  第二次反转
	// 5 6 7 1 2 3 4  第三次反转
	//+++++++++++++++++++++++++++++++++++++++++++++++++//
}
